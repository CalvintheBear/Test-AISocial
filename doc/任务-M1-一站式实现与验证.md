M1 一站式实现与验证（Claude 可直接执行的完整任务单）

---

### 给 Claude 的执行提示词（请严格按此执行）

你是资深全栈工程师，目标是一次性打通从前端到 Workers API 的最小可用链路（替换 mocks），并给出可本地验证的结果。请严格按“任务清单”和“完成标准”执行，边改边自测。除非被要求，否则不要变更无关文件与样式。

- 严格遵守本仓库结构与已有代码风格。
- 仅在标注的文件处新增/修改；不要重构无关代码。
- 所有新增 TypeScript 代码必须类型可通过；不得引入 any。
- 在“验收自测脚本”中逐条执行并确保成功。

---

## 范围与目标

- 打通最小链路：前端从 API 获取真实数据（非 mocks），实现 Feed、用户作品、收藏、作品详情 + 点赞/收藏/发布 操作的后端接口（具备最小功能且可运行）。
- Workers 侧：实现基础中间件、业务路由及对 D1/R2/Redis 的最小封装；在未配置真实服务时，使用“受控模拟”保障可自测（DEV_MODE）。
- 前端侧：`authFetch` 注入开发态 JWT；切换 `NEXT_PUBLIC_USE_MOCK=0` 后默认走 `/api/*`。

---

## 任务清单（按序执行）

1) Workers 基础与中间件
- 新增 `apps/worker-api/src/middlewares/auth.ts`：
  - 生产：用 `@clerk/backend` 校验 `Authorization: Bearer <JWT>`，将 `userId` 注入 `c.var.userId`。
  - 开发：当 `DEV_MODE=1` 或缺少 `CLERK_ISSUER` 时，允许通过并注入 `userId='dev-user'`（仅本地）。
- 新增 `apps/worker-api/src/utils/response.ts`：`ok(data)` 与 `fail(code,message,status=400)`。

2) Workers 服务封装（最小版）
- 新增 `apps/worker-api/src/services/redis.ts`：基于 Upstash REST 的最小客户端（`get/set/incr/sadd/srem/smembers`）。未配置时走内存 Map 存根（DEV_MODE）。
- 新增 `apps/worker-api/src/services/d1.ts`：封装最小查询（按蓝图表结构）：
  - `getArtwork(id)`、`listUserArtworks(userId)`、`listFeed(limit=20)`。
  - `likeArtwork(userId,id)`、`unlikeArtwork(userId,id)` → 返回最新 likeCount（若无 D1/Redis 则内存计数）。
  - `favArtwork(userId,id)`、`unfavArtwork(userId,id)`。
  - `publishArtwork(id)`。
  - 未绑定 DB 时，走内存存根并预置少量 demo 数据。
- 新增 `apps/worker-api/src/services/r2.ts`：占位 `put/get`（DEV_MODE 下返回占位 URL）。

3) Workers 路由（按蓝图）
- 修改 `apps/worker-api/src/index.ts`：注册并挂载路由，启用 `auth` 与 `error` 中间件。
- 新增 `apps/worker-api/src/routers/artworks.ts`：
  - `GET /api/artworks/:id` → 返回 `ArtworkDetail`。
  - `POST /api/artworks/:id/like` 与 `DELETE /api/artworks/:id/like`。
  - `POST /api/artworks/:id/favorite` 与 `DELETE /api/artworks/:id/favorite`。
  - `POST /api/artworks/:id/publish`。
- 新增 `apps/worker-api/src/routers/users.ts`：
  - `GET /api/users/:id/artworks`
  - `GET /api/users/:id/favorites`
- 新增 `apps/worker-api/src/routers/feed.ts`：
  - `GET /api/feed`（支持 `?limit=`）

4) D1 迁移（如需）
- 新增 `apps/worker-api/migrations/001_init.sql`（使用蓝图中的 SQL）。
- 在 README 片段中标注：`wrangler d1 migrations apply <DB_NAME>` 的命令（可选，DEV_MODE 可跳过）。

5) 前端切换到 API
- 修改 `apps/web/lib/api/client.ts`：
  - 若 `process.env.NEXT_PUBLIC_DEV_JWT` 存在，则注入 `Authorization: Bearer <token>`。
  - 保持 `isMockEnabled()` 逻辑不变。
- 调整 `apps/web/app/*` SSR 获取数据：当 `NEXT_PUBLIC_USE_MOCK=0` 时从 `/api/*` 拉取。

6) 环境与脚本
- 新增根部 `.env.example` 与 `apps/web/.env.local.example`、`apps/worker-api/.dev.vars.example`：列出所需变量与示例值。
- 在 `package.json` 增加本地联调脚本说明（文档即可，不必改代码）：
  - `npm --workspace apps/worker-api run dev`
  - `npm --workspace apps/web run dev`

---

## 目录&文件改动示例

```text
apps/worker-api/
  src/
    index.ts                  # 扩充：路由注册
    types.ts
    middlewares/
      auth.ts                 # 新增
    utils/
      response.ts             # 新增
    services/
      d1.ts                   # 新增（含内存存根）
      r2.ts                   # 新增（占位）
      redis.ts                # 新增（Upstash + 内存）
    routers/
      artworks.ts             # 新增
      users.ts                # 新增
      feed.ts                 # 新增
  migrations/
    001_init.sql              # 新增（蓝图 SQL）

apps/web/
  lib/
    api/
      client.ts               # 修改：注入 DEV_JWT
```

---

## 关键示例代码（片段）

> 中间件：`apps/worker-api/src/middlewares/auth.ts`
```ts
import type { Context, Next } from 'hono'

export async function authMiddleware(c: Context, next: Next) {
  const devMode = c.env?.DEV_MODE === '1' || !c.env?.CLERK_ISSUER
  if (devMode) {
    // 开发态放行
    // @ts-expect-error
    c.set('userId', 'dev-user')
    return next()
  }
  const auth = c.req.header('authorization') || c.req.header('Authorization')
  if (!auth?.startsWith('Bearer ')) return c.json({ code: 'AUTH_REQUIRED' }, 401)
  const token = auth.slice('Bearer '.length)
  // TODO: 使用 @clerk/backend 验证 token，并注入 userId
  // @ts-expect-error
  c.set('userId', 'todo-from-clerk')
  return next()
}
```

> 统一响应：`apps/worker-api/src/utils/response.ts`
```ts
export const ok = <T>(data: T) => ({ success: true, data })
export const fail = (code: string, message: string) => ({ success: false, code, message })
```

> Redis（最小封装，DEV 内存存根）：`apps/worker-api/src/services/redis.ts`
```ts
type MemorySet = Set<string>
const mem = {
  likes: new Map<string, number>(),
  favs: new Map<string, MemorySet>(),
}

export class RedisService {
  constructor(private url?: string, private token?: string) {}
  static fromEnv(env: any) {
    return new RedisService(env.UPSTASH_REDIS_REST_URL, env.UPSTASH_REDIS_REST_TOKEN)
  }
  async incrLikes(artworkId: string, delta: number) {
    const cur = mem.likes.get(artworkId) || 0
    const next = Math.max(0, cur + delta)
    mem.likes.set(artworkId, next)
    return next
  }
  async addFav(userId: string, artworkId: string) {
    const s = mem.favs.get(userId) || new Set<string>()
    s.add(artworkId)
    mem.favs.set(userId, s)
  }
  async removeFav(userId: string, artworkId: string) {
    mem.favs.get(userId)?.delete(artworkId)
  }
  async listFav(userId: string) {
    return Array.from(mem.favs.get(userId) || [])
  }
}
```

> D1（最小封装 + DEV 内存数据）：`apps/worker-api/src/services/d1.ts`
```ts
export type User = { id: string; name: string; profilePic?: string }
export type Artwork = {
  id: string; slug: string; title: string; url: string; status: 'draft' | 'published';
  author: User; likeCount: number; isFavorite?: boolean; createdAt: number
}

const devUser: User = { id: 'dev-user', name: '演示用户' }
const memArtworks: Map<string, Artwork> = new Map(
  [
    ['a1', { id: 'a1', slug: 'cyber-cat', title: '赛博朋克猫咪', url: 'https://via.placeholder.com/800x800/3b74ff/ffffff?text=赛博朋克猫咪', status: 'published', author: devUser, likeCount: 3, createdAt: Date.now() - 86400000 }],
    ['a2', { id: 'a2', slug: 'sunrise', title: '日出', url: 'https://via.placeholder.com/800x800/ff8844/ffffff?text=日出', status: 'draft', author: devUser, likeCount: 1, createdAt: Date.now() - 43200000 }],
  ]
)

export class D1Service {
  constructor(private db?: D1Database) {}
  static fromEnv(env: any) { return new D1Service(env.DB) }
  async getArtwork(id: string) { return memArtworks.get(id) || null }
  async listFeed(limit = 20) { return Array.from(memArtworks.values()).filter(a=>a.status==='published').slice(0, limit) }
  async listUserArtworks(userId: string) { return Array.from(memArtworks.values()).filter(a=>a.author.id === userId) }
  async publishArtwork(id: string) { const a = memArtworks.get(id); if (a) a.status = 'published'; return a }
}
```

> 路由（片段）：`apps/worker-api/src/routers/artworks.ts`
```ts
import { Hono } from 'hono'
import { D1Service } from '../services/d1'
import { RedisService } from '../services/redis'
import { ok, fail } from '../utils/response'

const router = new Hono()

router.get('/:id', async (c) => {
  const id = c.req.param('id')
  const d1 = D1Service.fromEnv(c.env)
  const art = await d1.getArtwork(id)
  if (!art) return c.json(fail('NOT_FOUND', 'Artwork not found'), 404)
  const detail = {
    id: art.id, slug: art.slug, title: art.title, originalUrl: art.url,
    createdAt: art.createdAt, status: art.status, author: art.author,
    likeCount: art.likeCount, isFavorite: false,
  }
  return c.json(ok(detail))
})

router.post('/:id/like', async (c) => {
  const id = c.req.param('id')
  const redis = RedisService.fromEnv(c.env)
  const likeCount = await redis.incrLikes(id, 1)
  return c.json(ok({ likeCount, isLiked: true }))
})

router.delete('/:id/like', async (c) => {
  const id = c.req.param('id')
  const redis = RedisService.fromEnv(c.env)
  const likeCount = await redis.incrLikes(id, -1)
  return c.json(ok({ likeCount, isLiked: false }))
})

router.post('/:id/favorite', async (c) => {
  // @ts-expect-error
  const userId = c.get('userId') as string
  const id = c.req.param('id')
  const redis = RedisService.fromEnv(c.env)
  await redis.addFav(userId, id)
  return c.json(ok({ is_favorite: true }))
})

router.delete('/:id/favorite', async (c) => {
  // @ts-expect-error
  const userId = c.get('userId') as string
  const id = c.req.param('id')
  const redis = RedisService.fromEnv(c.env)
  await redis.removeFav(userId, id)
  return c.json(ok({ is_favorite: false }))
})

router.post('/:id/publish', async (c) => {
  const id = c.req.param('id')
  const d1 = D1Service.fromEnv(c.env)
  const art = await d1.publishArtwork(id)
  if (!art) return c.json(fail('NOT_FOUND', 'Artwork not found'), 404)
  return c.json(ok({ status: 'published', id }))
})

export default router
```

> 路由注册：`apps/worker-api/src/index.ts`（示例扩充）
```ts
import { Hono } from 'hono'
import type { Env } from './types'
import { authMiddleware } from './middlewares/auth'
import artworks from './routers/artworks'
import users from './routers/users'
import feed from './routers/feed'

const app = new Hono<{ Bindings: Env }>()

app.get('/api/health', (c) => c.json({ ok: true, env: 'workers', time: Date.now() }))
app.get('/api/redis/ping', async (c) => c.json({ ok: true }))

app.use('/api/*', authMiddleware)
app.route('/api/artworks', artworks)
app.route('/api/users', users)
app.route('/api/feed', feed)

export default app
```

> 前端 `authFetch`：`apps/web/lib/api/client.ts`（注入开发态 JWT）
```ts
export async function authFetch<T = any>(input: RequestInfo, init: RequestInit = {}) {
  const devJwt = process.env.NEXT_PUBLIC_DEV_JWT
  const headers = {
    'Content-Type': 'application/json',
    ...(init.headers || {}),
    ...(devJwt ? { Authorization: `Bearer ${devJwt}` } : {}),
  }
  const res = await fetch(input, { ...init, headers, cache: 'no-store' })
  if (!res.ok) {
    let err: any
    try { err = await res.json() } catch { err = { message: res.statusText } }
    throw err
  }
  return res.json() as Promise<T>
}
```

> D1 迁移：`apps/worker-api/migrations/001_init.sql`
```sql
-- 基于蓝图文档的表结构（可直接使用）
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  profile_pic TEXT
);

CREATE TABLE IF NOT EXISTS artworks (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  title TEXT,
  url TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('draft','published')),
  created_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS artworks_like (
  user_id TEXT NOT NULL,
  artwork_id TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  PRIMARY KEY (user_id, artwork_id)
);

CREATE TABLE IF NOT EXISTS artworks_favorite (
  user_id TEXT NOT NULL,
  artwork_id TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  PRIMARY KEY (user_id, artwork_id)
);
```

---

## 环境变量示例（已配置 wrangler secrets，可按需覆盖）

> `apps/worker-api/.dev.vars`（已为你创建，含开发占位值，可直接本地运行）
```env
DEV_MODE=1
UPSTASH_REDIS_REST_URL= # 可留空
UPSTASH_REDIS_REST_TOKEN= # 可留空
CLERK_ISSUER= # 可留空（留空即走 DEV）
```

> `apps/web/.env.local`（若未生成，请手动创建文件并粘贴）
```env
NEXT_PUBLIC_USE_MOCK=0
NEXT_PUBLIC_SITE_URL=http://localhost:3000
NEXT_PUBLIC_DEV_JWT=dev
```

---

## 验收自测脚本（Claude 必须逐条通过）

1) 启动后端（DEV）
```bash
npm --workspace apps/worker-api run dev
# 预期：/api/health 返回 { ok: true }
```

2) 启动前端（DEV）
```bash
npm --workspace apps/web run dev
# 访问 http://localhost:3000/feed 应展示来自 /api/feed 的数据（非 mocks）
```

3) cURL 接口验证
```bash
# Feed
curl -s http://127.0.0.1:8787/api/feed | jq

# 作品详情
curl -s http://127.0.0.1:8787/api/artworks/a1 | jq

# 点赞/取消点赞
curl -s -X POST http://127.0.0.1:8787/api/artworks/a1/like | jq
curl -s -X DELETE http://127.0.0.1:8787/api/artworks/a1/like | jq

# 收藏/取消收藏（需要 dev-user 注入，DEV_MODE 下自动注入）
curl -s -X POST http://127.0.0.1:8787/api/artworks/a1/favorite | jq
curl -s -X DELETE http://127.0.0.1:8787/api/artworks/a1/favorite | jq
```

4) 前端交互验证
- 详情页点赞计数随操作变化
- 收藏按钮状态切换
- `/user/:username` 与 `/feed` 列表可渲染

---

## 完成标准（必须全部满足）

- 代码可运行：本地 DEV（无真实 D1/R2/Redis/Clerk）可完成端到端演示。
- 所有新增/修改 TS 文件通过类型检查；不引入 ESLint 新错误。
- 所有接口均返回与前端类型匹配的数据结构（`ArtworkListItem[]`、`ArtworkDetail`、like/fav/publish 响应）。
- `NEXT_PUBLIC_USE_MOCK=0` 时，前端默认走 `/api/*`。
- 文档中的自测步骤全部通过。

---

## 超出项（可选，加分）

- 抽离 Redis 计数持久化策略（定时回写 D1）。
- `generateMetadata` 动态 SEO：详情页由接口返回填充。
- 引入 Zod 对请求参数与响应体做最小校验。

---

如需进一步扩展，请参考：`doc/AI社区全流程架构蓝图.md` 与 `doc/全流程技术实现规划.md`。


