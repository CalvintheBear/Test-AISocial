# AI Social点赞收藏系统问题分析与完整修复方案

## 问题总结与整合分析

### 核心问题
AI Social平台的点赞收藏系统存在两个主要问题：

1. **状态记忆失效**：用户点赞/收藏后，在不同页面间切换时状态无法保持一致
2. **数量回滚现象**：用户操作后数量显示异常，切换页面后数值发生变化

### 根本原因分析

#### 架构层面问题
- **缓存层级不统一**：个人主页使用SWR缓存，Feed页使用本地状态，详情页独立管理
- **数据同步机制缺失**：缺少跨页面状态同步机制
- **Optimistic Update与真实数据冲突**：前端乐观更新与后端真实数据计算方式不匹配

#### 技术实现问题
- **缓存失效策略不当**：操作后相关缓存未及时更新
- **错误处理不完善**：网络异常时无合理回退机制
- **SSR/CSR状态不一致**：服务端渲染与客户端状态不同步

## 完整修复方案

### 修复策略概览

#### 1. 统一状态管理层
- 使用SWR全局缓存管理点赞收藏状态
- 建立统一的缓存键命名规范
- 实现跨页面状态同步

#### 2. 优化数据一致性
- 改进缓存失效策略
- 添加操作后自动刷新机制
- 实现渐进式数据同步

#### 3. 增强用户体验
- 添加操作状态指示器
- 实现智能重试机制
- 提供手动刷新选项

### 具体实施方案

#### 方案一：统一状态管理架构（推荐）

##### 1. 创建全局状态管理Hook

```typescript
// hooks/useArtworkState.ts
import useSWR from 'swr';
import { useCallback } from 'react';

interface ArtworkState {
  like_count: number;
  fav_count: number;
  user_state: {
    liked: boolean;
    faved: boolean;
  };
}

interface ArtworkStateManager {
  getArtworkState: (artworkId: string) => ArtworkState | undefined;
  toggleLike: (artworkId: string) => Promise<void>;
  toggleFavorite: (artworkId: string) => Promise<void>;
  refreshArtwork: (artworkId: string) => Promise<void>;
  refreshAll: () => Promise<void>;
}

export function useArtworkState(artworkId: string) {
  const { data, error, mutate } = useSWR<ArtworkState>(
    artworkId ? `/api/artworks/${artworkId}/state` : null,
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      dedupingInterval: 5000,
    }
  );

  const toggleLike = useCallback(async () => {
    if (!artworkId) return;

    // Optimistic update
    mutate(
      (current) => {
        if (!current) return current;
        return {
          ...current,
          like_count: current.user_state.liked 
            ? Math.max(0, current.like_count - 1) 
            : current.like_count + 1,
          user_state: {
            ...current.user_state,
            liked: !current.user_state.liked,
          },
        };
      },
      false // 不重新验证，等待API响应
    );

    try {
      const response = await fetch(`/api/artworks/${artworkId}/like`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      const result = await response.json();
      
      if (result.success) {
        mutate(result.data, false);
        // 广播更新到所有相关缓存
        mutate(`/api/artworks/${artworkId}`, result.data, false);
        mutate('/api/feed', undefined, { revalidate: true });
      }
    } catch (error) {
      console.error('Failed to toggle like:', error);
      // 回滚到之前状态
      mutate();
    }
  }, [artworkId, mutate]);

  const toggleFavorite = useCallback(async () => {
    if (!artworkId) return;

    mutate(
      (current) => {
        if (!current) return current;
        return {
          ...current,
          fav_count: current.user_state.faved 
            ? Math.max(0, current.fav_count - 1) 
            : current.fav_count + 1,
          user_state: {
            ...current.user_state,
            faved: !current.user_state.faved,
          },
        };
      },
      false
    );

    try {
      const response = await fetch(`/api/artworks/${artworkId}/favorite`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      const result = await response.json();
      
      if (result.success) {
        mutate(result.data, false);
        mutate(`/api/artworks/${artworkId}`, result.data, false);
        mutate('/api/feed', undefined, { revalidate: true });
        mutate('/api/users/me/favorites', undefined, { revalidate: true });
      }
    } catch (error) {
      console.error('Failed to toggle favorite:', error);
      mutate();
    }
  }, [artworkId, mutate]);

  const refreshArtwork = useCallback(async () => {
    mutate();
  }, [mutate]);

  return {
    state: data,
    isLoading: !error && !data,
    isError: error,
    toggleLike,
    toggleFavorite,
    refreshArtwork,
  };
}
```

##### 2. 创建全局状态管理器

```typescript
// lib/artworkStateManager.ts
import { mutate } from 'swr';

class ArtworkStateManager {
  private static instance: ArtworkStateManager;
  
  static getInstance(): ArtworkStateManager {
    if (!ArtworkStateManager.instance) {
      ArtworkStateManager.instance = new ArtworkStateManager();
    }
    return ArtworkStateManager.instance;
  }

  // 更新单个作品状态
  async updateArtworkState(artworkId: string, newState: any) {
    mutate(`/api/artworks/${artworkId}/state`, newState, false);
    mutate(`/api/artworks/${artworkId}`, newState, false);
  }

  // 批量更新作品状态
  async batchUpdateArtworkStates(updates: Array<{ artworkId: string, state: any }>) {
    updates.forEach(({ artworkId, state }) => {
      this.updateArtworkState(artworkId, state);
    });
  }

  // 刷新所有相关缓存
  async refreshAll() {
    mutate('/api/feed');
    mutate((key) => typeof key === 'string' && key.startsWith('/api/artworks/'));
    mutate((key) => typeof key === 'string' && key.includes('/favorites'));
  }

  // 获取缓存键
  getArtworkStateKey(artworkId: string) {
    return `/api/artworks/${artworkId}/state`;
  }

  getFeedKey() {
    return '/api/feed';
  }

  getUserFavoritesKey(userId: string) {
    return `/api/users/${userId}/favorites`;
  }
}

export const artworkStateManager = ArtworkStateManager.getInstance();
```

##### 3. 创建增强版LikeButton组件

```typescript
// components/EnhancedLikeButton.tsx
import React, { useState, useEffect } from 'react';
import { Heart } from 'lucide-react';
import { useArtworkState } from '@/hooks/useArtworkState';
import { cn } from '@/lib/utils';

interface EnhancedLikeButtonProps {
  artworkId: string;
  initialState?: {
    liked: boolean;
    likeCount: number;
  };
  className?: string;
  showCount?: boolean;
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export function EnhancedLikeButton({
  artworkId,
  initialState,
  className,
  showCount = true,
  onSuccess,
  onError,
}: EnhancedLikeButtonProps) {
  const { state, toggleLike, isLoading, isError } = useArtworkState(artworkId);
  const [isAnimating, setIsAnimating] = useState(false);

  // 使用初始状态或从全局状态获取
  const liked = state?.user_state.liked ?? initialState?.liked ?? false;
  const likeCount = state?.like_count ?? initialState?.likeCount ?? 0;

  const handleClick = async (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    if (isLoading) return;

    setIsAnimating(true);
    
    try {
      await toggleLike();
      onSuccess?.();
    } catch (error) {
      onError?.(error as Error);
    } finally {
      setTimeout(() => setIsAnimating(false), 300);
    }
  };

  const handleRetry = () => {
    // 重新获取最新状态
    // 这里可以调用refreshArtwork
  };

  return (
    <div className="flex items-center space-x-2">
      <button
        onClick={handleClick}
        disabled={isLoading}
        className={cn(
          'flex items-center space-x-1 transition-all duration-200',
          'hover:scale-110 active:scale-95',
          liked && 'text-red-500',
          isLoading && 'opacity-50 cursor-not-allowed',
          isAnimating && 'animate-pulse',
          className
        )}
        aria-label={liked ? '取消点赞' : '点赞'}
      >
        <Heart
          className={cn(
            'h-5 w-5 transition-all',
            liked ? 'fill-current' : 'fill-none'
          )}
        />
        {showCount && (
          <span className="text-sm font-medium tabular-nums">
            {isLoading ? '...' : likeCount}
          </span>
        )}
      </button>

      {isError && (
        <button
          onClick={handleRetry}
          className="text-xs text-red-500 hover:text-red-700"
          title="点击重试"
        >
          ⚠️
        </button>
      )}
    </div>
  );
}
```

##### 4. 创建FavoriteButton组件

```typescript
// components/EnhancedFavoriteButton.tsx
import React, { useState } from 'react';
import { Bookmark } from 'lucide-react';
import { useArtworkState } from '@/hooks/useArtworkState';
import { cn } from '@/lib/utils';

interface EnhancedFavoriteButtonProps {
  artworkId: string;
  initialState?: {
    faved: boolean;
    favCount: number;
  };
  className?: string;
  showCount?: boolean;
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export function EnhancedFavoriteButton({
  artworkId,
  initialState,
  className,
  showCount = true,
  onSuccess,
  onError,
}: EnhancedFavoriteButtonProps) {
  const { state, toggleFavorite, isLoading, isError } = useArtworkState(artworkId);
  const [isAnimating, setIsAnimating] = useState(false);

  const faved = state?.user_state.faved ?? initialState?.faved ?? false;
  const favCount = state?.fav_count ?? initialState?.favCount ?? 0;

  const handleClick = async (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    if (isLoading) return;

    setIsAnimating(true);
    
    try {
      await toggleFavorite();
      onSuccess?.();
    } catch (error) {
      onError?.(error as Error);
    } finally {
      setTimeout(() => setIsAnimating(false), 300);
    }
  };

  return (
    <div className="flex items-center space-x-2">
      <button
        onClick={handleClick}
        disabled={isLoading}
        className={cn(
          'flex items-center space-x-1 transition-all duration-200',
          'hover:scale-110 active:scale-95',
          faved && 'text-yellow-500',
          isLoading && 'opacity-50 cursor-not-allowed',
          isAnimating && 'animate-pulse',
          className
        )}
        aria-label={faved ? '取消收藏' : '收藏'}
      >
        <Bookmark
          className={cn(
            'h-5 w-5 transition-all',
            faved ? 'fill-current' : 'fill-none'
          )}
        />
        {showCount && (
          <span className="text-sm font-medium tabular-nums">
            {isLoading ? '...' : favCount}
          </span>
        )}
      </button>

      {isError && (
        <button
          onClick={() => window.location.reload()} // 简单重试
          className="text-xs text-red-500 hover:text-red-700"
          title="同步失败，点击刷新"
        >
          ⚠️
        </button>
      )}
    </div>
  );
}
```

#### 方案二：渐进式迁移方案

##### 1. 创建兼容性Hook

```typescript
// hooks/useCompatibleArtworkActions.ts
import { useState, useCallback } from 'react';
import { artworkStateManager } from '@/lib/artworkStateManager';

export function useCompatibleArtworkActions(artworkId: string, initialData?: any) {
  const [localState, setLocalState] = useState({
    liked: initialData?.user_state?.liked ?? false,
    faved: initialData?.user_state?.faved ?? false,
    like_count: initialData?.like_count ?? 0,
    fav_count: initialData?.fav_count ?? 0,
  });

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const syncWithGlobalState = useCallback(async () => {
    // 与新系统同步
    try {
      const response = await fetch(`/api/artworks/${artworkId}/state`);
      const data = await response.json();
      setLocalState({
        liked: data.user_state.liked,
        faved: data.user_state.faved,
        like_count: data.like_count,
        fav_count: data.fav_count,
      });
    } catch (e) {
      console.error('Failed to sync state:', e);
    }
  }, [artworkId]);

  const toggleLike = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/artworks/${artworkId}/like`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      const result = await response.json();

      if (result.success) {
        setLocalState(prev => ({
          ...prev,
          liked: result.data.user_state.liked,
          like_count: result.data.like_count,
        }));
        
        // 同步到全局状态
        artworkStateManager.updateArtworkState(artworkId, result.data);
      }
    } catch (e) {
      setError(e as Error);
    } finally {
      setIsLoading(false);
    }
  }, [artworkId]);

  const toggleFavorite = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/artworks/${artworkId}/favorite`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      const result = await response.json();

      if (result.success) {
        setLocalState(prev => ({
          ...prev,
          faved: result.data.user_state.faved,
          fav_count: result.data.fav_count,
        }));
        
        artworkStateManager.updateArtworkState(artworkId, result.data);
      }
    } catch (e) {
      setError(e as Error);
    } finally {
      setIsLoading(false);
    }
  }, [artworkId]);

  return {
    ...localState,
    isLoading,
    error,
    toggleLike,
    toggleFavorite,
    syncWithGlobalState,
  };
}
```

#### 方案三：后端API优化

##### 1. 创建新的状态端点

```typescript
// apps/worker-api/src/routers/artworks.ts
import { Hono } from 'hono';
import { z } from 'zod';

const artworkStateRouter = new Hono();

// 获取单个作品完整状态
artworkStateRouter.get('/:id/state', async (c) => {
  const artworkId = c.req.param('id');
  const userId = c.get('userId');
  
  try {
    const [artwork, likeCount, favCount, userState] = await Promise.all([
      c.env.DB.prepare(`
        SELECT id, title, status, created_at 
        FROM artworks 
        WHERE id = ?
      `).bind(artworkId).first(),
      
      c.env.DB.prepare(`
        SELECT COUNT(*) as count 
        FROM artworks_like 
        WHERE artwork_id = ?
      `).bind(artworkId).first(),
      
      c.env.DB.prepare(`
        SELECT COUNT(*) as count 
        FROM artworks_favorite 
        WHERE artwork_id = ?
      `).bind(artworkId).first(),
      
      userId ? c.env.DB.prepare(`
        SELECT 
          CASE WHEN l.user_id IS NOT NULL THEN 1 ELSE 0 END as liked,
          CASE WHEN f.user_id IS NOT NULL THEN 1 ELSE 0 END as faved
        FROM artworks a
        LEFT JOIN artworks_like l ON a.id = l.artwork_id AND l.user_id = ?
        LEFT JOIN artworks_favorite f ON a.id = f.artwork_id AND f.user_id = ?
        WHERE a.id = ?
      `).bind(userId, userId, artworkId).first() : { liked: 0, faved: 0 }
    ]);

    if (!artwork) {
      return c.json({ error: 'Artwork not found' }, 404);
    }

    return c.json({
      success: true,
      data: {
        like_count: likeCount.count,
        fav_count: favCount.count,
        user_state: {
          liked: Boolean(userState.liked),
          faved: Boolean(userState.faved),
        }
      }
    });
  } catch (error) {
    console.error('Failed to get artwork state:', error);
    return c.json({ error: 'Internal server error' }, 500);
  }
});

// 批量获取作品状态
artworkStateRouter.post('/batch/state', async (c) => {
  const { artworkIds } = await c.req.json();
  const userId = c.get('userId');
  
  if (!Array.isArray(artworkIds) || artworkIds.length === 0) {
    return c.json({ error: 'Invalid artwork IDs' }, 400);
  }

  try {
    // 使用IN查询批量获取
    const placeholders = artworkIds.map(() => '?').join(',');
    
    const [likes, favorites, userStates] = await Promise.all([
      c.env.DB.prepare(`
        SELECT artwork_id, COUNT(*) as count 
        FROM artworks_like 
        WHERE artwork_id IN (${placeholders})
        GROUP BY artwork_id
      `).bind(...artworkIds).all(),
      
      c.env.DB.prepare(`
        SELECT artwork_id, COUNT(*) as count 
        FROM artworks_favorite 
        WHERE artwork_id IN (${placeholders})
        GROUP BY artwork_id
      `).bind(...artworkIds).all(),
      
      userId ? c.env.DB.prepare(`
        SELECT 
          a.id as artwork_id,
          CASE WHEN l.user_id IS NOT NULL THEN 1 ELSE 0 END as liked,
          CASE WHEN f.user_id IS NOT NULL THEN 1 ELSE 0 END as faved
        FROM artworks a
        LEFT JOIN artworks_like l ON a.id = l.artwork_id AND l.user_id = ?
        LEFT JOIN artworks_favorite f ON a.id = f.artwork_id AND f.user_id = ?
        WHERE a.id IN (${placeholders})
      `).bind(userId, userId, ...artworkIds).all() : { results: [] }
    ]);

    const resultMap = new Map();
    
    artworkIds.forEach(id => {
      resultMap.set(id, {
        like_count: 0,
        fav_count: 0,
        user_state: { liked: false, faved: false }
      });
    });

    likes.results.forEach(row => {
      if (resultMap.has(row.artwork_id)) {
        resultMap.get(row.artwork_id).like_count = row.count;
      }
    });

    favorites.results.forEach(row => {
      if (resultMap.has(row.artwork_id)) {
        resultMap.get(row.artwork_id).fav_count = row.count;
      }
    });

    userStates.results.forEach(row => {
      if (resultMap.has(row.artwork_id)) {
        resultMap.get(row.artwork_id).user_state = {
          liked: Boolean(row.liked),
          faved: Boolean(row.faved),
        };
      }
    });

    return c.json({
      success: true,
      data: Object.fromEntries(resultMap)
    });
  } catch (error) {
    console.error('Failed to get batch artwork states:', error);
    return c.json({ error: 'Internal server error' }, 500);
  }
});

export default artworkStateRouter;
```

##### 2. 缓存优化中间件

```typescript
// apps/worker-api/src/middlewares/cache.ts
import { Context, Next } from 'hono';

export async function cacheMiddleware(c: Context, next: Next) {
  const url = new URL(c.req.url);
  const cacheKey = `artwork_state:${url.pathname}${url.search}`;
  
  // 检查缓存
  if (c.req.method === 'GET') {
    const cached = await c.env.CACHE.get(cacheKey);
    if (cached) {
      return c.json(JSON.parse(cached));
    }
  }

  await next();

  // 缓存响应
  if (c.req.method === 'GET' && c.res.status === 200) {
    const response = await c.res.clone().json();
    await c.env.CACHE.put(cacheKey, JSON.stringify(response), {
      expirationTtl: 300 // 5分钟缓存
    });
  }
}

// 缓存失效工具
export class CacheInvalidator {
  static async invalidateArtwork(c: Context, artworkId: string) {
    const keys = [
      `artwork_state:/api/artworks/${artworkId}/state`,
      `/api/artworks/${artworkId}`,
      '/api/feed',
    ];
    
    await Promise.all(keys.map(key => c.env.CACHE.delete(key)));
  }

  static async invalidateUserFavorites(c: Context, userId: string) {
    await c.env.CACHE.delete(`/api/users/${userId}/favorites`);
  }
}
```

## 迁移计划

### 阶段一：准备阶段（1-2天）
1. 部署新的API端点
2. 创建兼容性Hook
3. 添加错误监控

### 阶段二：渐进式替换（3-5天）
1. 先用兼容性Hook替换现有组件
2. 测试新系统稳定性
3. 收集用户反馈

### 阶段三：完全迁移（2-3天）
1. 移除旧的状态管理代码
2. 启用新的全局状态管理
3. 优化性能

## 测试验证

### 单元测试
```typescript
// __tests__/useArtworkState.test.ts
import { renderHook, act } from '@testing-library/react';
import { useArtworkState } from '@/hooks/useArtworkState';

describe('useArtworkState', () => {
  it('should handle like toggle', async () => {
    const { result } = renderHook(() => useArtworkState('test-id'));
    
    await act(async () => {
      await result.current.toggleLike();
    });
    
    expect(result.current.state?.user_state.liked).toBe(true);
  });
});
```

### 集成测试
- 并发操作测试
- 网络异常测试
- 缓存一致性测试

### 性能测试
- 内存使用监控
- 响应时间测试
- 用户体验评估

## 监控与告警

### 关键指标
- 点赞/收藏操作成功率
- 状态同步延迟
- 缓存命中率
- 错误率

### 告警规则
- 操作失败率 > 1%
- 缓存命中率 < 80%
- 响应时间 > 2秒

## 回滚策略

### 快速回滚
1. 保留旧代码分支
2. 使用特性开关控制
3. 5分钟内可回滚

### 数据一致性保证
1. 所有操作幂等
2. 支持补偿操作
3. 数据校验机制

## 用户沟通

### 更新提示
- 添加"状态同步中"提示
- 显示最后更新时间
- 提供手动刷新选项

### 用户教育
- 更新帮助文档
- 添加操作指南
- 收集用户反馈

这个修复方案通过统一状态管理层、优化缓存策略、增强错误处理来解决点赞收藏系统的所有问题，同时提供了渐进式迁移路径，确保系统稳定性。